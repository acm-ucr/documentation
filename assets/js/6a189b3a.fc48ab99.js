"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[919],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8878:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:1},i="useState",s={unversionedId:"react-hooks/useState",id:"react-hooks/useState",title:"useState",description:'Allows React applications to "remember" information in the form of state variables. Keeps track of information regardless of rerenders.',source:"@site/docs/react-hooks/useState.md",sourceDirName:"react-hooks",slug:"/react-hooks/useState",permalink:"/docusaurus/docs/react-hooks/useState",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"React Hooks",permalink:"/docusaurus/docs/category/react-hooks"},next:{title:"useEffect",permalink:"/docusaurus/docs/react-hooks/useEffect"}},l={},u=[{value:"Initializing and Using a State Variable",id:"initializing-and-using-a-state-variable",level:2},{value:"Async Operation",id:"async-operation",level:2}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"usestate"},"useState"),(0,o.kt)("p",null,'Allows React applications to "remember" information in the form of state variables. Keeps track of information regardless of rerenders.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"setState")," operation is not an ",(0,o.kt)("inlineCode",{parentName:"p"},"O(1)")," operation which may result in discrepancies explained further. It is more accurately described as an ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," operation."),(0,o.kt)("h2",{id:"initializing-and-using-a-state-variable"},"Initializing and Using a State Variable"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'"use client";\nimport { useState } from "react";\n\nconst Component = () => {\n  const [data, setData] = useState("Hello World");\n\n  return <>{data}</>;\n};\n')),(0,o.kt)("p",null,"Let's walk through the code understanding each segment."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'"use client";\n')),(0,o.kt)("p",null,"This is required whenever using React Hooks, it converts the given component/file from a React Server Component (RSC) to a React Client Component (RCC). This feature was introduced in React 18 and provides major performance benefits. However, when using RSC we are not able to take advantage of that performance boost at the cost of storing information."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useState } from "react";\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useState")," is not automatically provided to us and we must import it from React. There are multiple ways to import ",(0,o.kt)("inlineCode",{parentName:"p"},"useState"),", however, the above method is the recommended manner."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'const [data, setData] = useState("Hello World");\n')),(0,o.kt)("p",null,"This is the core of the ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," hook. We define an array with 2 elements: a value and a function to change that value. In the scenario above we have the value ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and a function ",(0,o.kt)("inlineCode",{parentName:"p"},"setData")," which allows us to change the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"data"),". The value inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"useState()")," is the default value for when the component initially loads. Hence, when the above component initially loads, it will render ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello World"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"return <>{data}</>;\n")),(0,o.kt)("p",null,"In order to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," variable, we can use curly braces to escape the HTML and insert Javascript which will render the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"data"),"."),(0,o.kt)("h2",{id:"async-operation"},"Async Operation"),(0,o.kt)("p",null,"As mentioned before, ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," is not a synchronous operation, but rather an asynchronous operation, which impacts the way information updates and is displayed. Consider the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const [counter, setCounter] = useState(0);\n\nconst handleClick = () => {\n  setCounter(counter + 1);\n  setCounter(counter + 1);\n};\n")),(0,o.kt)("p",null,"After the ",(0,o.kt)("inlineCode",{parentName:"p"},"handleClick")," function is ran, we expect the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"counter")," to be 2, since we are adding 1 twice. However, in reality, it will set the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"counter")," to 1. This happens since when both function calls are fired, the value of counter is still 0 at the time, and when they both finish at relatively the same time, they update counter to be 1."),(0,o.kt)("p",null,"One improvement to the above function would be to utilize the previous value and increment based off of that, ensuring we always have the most up to date information."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const [counter, setCounter] = useState(0);\n\nconst handleClick = () => {\n  setCounter((prev) => prev + 1);\n  setCounter((prev) => prev + 1);\n};\n")),(0,o.kt)("p",null,"When running ",(0,o.kt)("inlineCode",{parentName:"p"},"handleClick")," now, we will get the expected value of 2, as it takes in the previous value and utilizes that. This is a very simple example and some refactoring can easily make this much better. In most cases, we will not need to use such syntax, instead we can do something of the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const [counter, setCounter] = useState(0);\n\nconst handleClick = () => {\n  setCounter(counter + 2);\n};\n")),(0,o.kt)("p",null,"This refactored version solves our problem and ensure we do not run into unnecessary overwrites. However, we still may run into situations where we need that updated value to run some other computation. Such as the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const [counter, setCounter] = useState(0);\n\nconst handleClick = () => {\n  setCounter(counter + 2);\n\n  console.log(counter);\n};\n")),(0,o.kt)("p",null,"Here, we expect counter to have the updated value when we ",(0,o.kt)("inlineCode",{parentName:"p"},"console.log()")," the value, however, we will see an outdated value. To counter this, we can refactor our code to the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const [counter, setCounter] = useState(0);\n\nconst handleClick = () => {\n  const updated = counter + 2;\n  setCounter(updated);\n\n  console.log(updated);\n};\n")),(0,o.kt)("p",null,"The refactored version now provides both operations the most updated value of counter as creating a regular Javascript variable is still a ",(0,o.kt)("inlineCode",{parentName:"p"},"O(1)")," operation."))}d.isMDXComponent=!0}}]);